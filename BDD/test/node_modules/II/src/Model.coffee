moduleKeywords = ['extended', 'included']

Object.prototype.getPrototype = ->
	Object.getPrototypeOf @

Object.prototype.clone = -> 
  newObj = if (@ instanceof Array) then [] else {};
  for key, value of @ 
    if key == 'clone' then continue;
    if value and typeof value == "object" 
      newObj[key] = value.clone()
    else newObj[key] = value
   return newObj



class Model

	@reccords: null
	@head: 0
	@get: (which) -> @reccords[which] ?= null
	@delete = (which) -> "Nu inca"
	@create: (args, id) -> 

		@reccords ?= {}

		args ?= {}
		args.__id ?= args.id or @head
		id = args.__id

		@reccords[@head] = new @(args)

		@reccords[id] = @reccords[@head] if id?
		@reccords[@head++]

	@reuse: (which, args) -> 
		@reccords ?= {}
		args ?= {}
		unless @reccords[which]?
			args.id = which
			return @create(args) 
		return @get(which)


	@extend: (obj) ->
		obj = obj.clone()
		@[key] = value for key, value of obj when key not in moduleKeywords
		obj.extended?.call(@)
		this

	@include: (obj) ->
		obj = obj.clone()
		@::[key] = value for key, value of obj when key not in moduleKeywords
		obj.included?.call(@)
		this

	@proxy: () ->
		what = arguments[0]
		to = arguments[1]
		if typeof what == "function" 
			return (args...) => 
				what.apply to, args
		else return @[what]

	@remove: (id) ->
		@reccords[id] = null

	@fn =  @

	constructor: (args) ->
		valueSet = {}
		__id = args["__id"] or null
		@init.call(@, args)
		@[key] = value for key, value of args

	init: () ->
	extended: () ->
	included: () ->

	remove: () ->
		@parent.remove @id
		
class chestie extends Model
	@classfunc: -> "Class"
	protofunc: -> "Proto"

module.exports = Model
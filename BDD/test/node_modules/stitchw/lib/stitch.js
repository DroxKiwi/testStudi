// Generated by CoffeeScript 1.9.1
(function() {
  var CoffeeScript, Handlebars, LiveScript, Package, _, async, babel, compilers, eco, err, error, exec, execSync, extname, extractClass, fs, jade, join, less, md, mime, normalize, ref, renderElement, renderer, wrapAddClass, yaml,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    slice = [].slice;

  _ = require('underscore');

  async = require('async');

  fs = require('fs');

  ref = require('path'), extname = ref.extname, join = ref.join, normalize = ref.normalize;

  exports.compilers = compilers = {
    js: function(module, filename) {
      var content;
      content = fs.readFileSync(filename, 'utf8');
      return module._compile(content, filename);
    }
  };

  try {
    babel = require('babel');
    compilers.js = function(module, filename) {
      var content;
      content = fs.readFileSync(filename, 'utf8');
      if ((filename.indexOf(".esn")) >= 0) {
        return module._compile((babel.transform(content, {
          stage: 1
        })).code, filename);
      } else {
        return module._compile(content, filename);
      }
    };
  } catch (_error) {
    err = _error;
  }

  try {
    CoffeeScript = require('coffee-script');
    compilers.coffee = function(module, filename) {
      var content;
      content = CoffeeScript.compile(fs.readFileSync(filename, 'utf8'));
      return module._compile(content, filename);
    };
  } catch (_error) {
    err = _error;
  }

  try {
    LiveScript = require('LiveScript');
    compilers.ls = function(module, filename) {
      var content;
      content = LiveScript.compile(fs.readFileSync(filename, 'utf8'), {
        prelude: true
      });
      return module._compile(content, filename);
    };
  } catch (_error) {
    err = _error;
  }

  try {
    exec = require("child_process").exec;
    execSync = require("exec-sync");
    compilers.ts = function(module, filename) {
      var child, content, newfile;
      newfile = filename.substr(0, filename.lastIndexOf(".")) + ".js";
      child = execSync("tsc " + filename);
      content = fs.readFileSync("" + newfile, 'utf8');
      fs.unlink(newfile);
      return module._compile(content, filename);
    };
  } catch (_error) {
    err = _error;
  }

  try {
    compilers.html = compilers.html = function(module, filename) {
      var content;
      content = fs.readFileSync(filename, "utf8");
      content = content.replace(/\\?"/g, "\\\"");
      content = content.replace(/\r?\n/g, "\\n");
      return module._compile("module.exports = \"" + content + "\"", filename);
    };
  } catch (_error) {
    err = _error;
  }

  try {
    md = require("marked");
    renderer = new md.Renderer();
    extractClass = function(text, next) {
      var cls, e;
      try {
        cls = text.match(/^(\.[a-zA-Z0-9]*)+/);
        if (cls != null) {
          return next(text.replace(cls[0], ""), cls[0].split(".").join(" "));
        } else {
          return next(text, null);
        }
      } catch (_error) {
        e = _error;
        return console.log(e.message);
      }
    };
    renderElement = function(text, cls, element) {
      if (cls != null) {
        return "<" + element + " class='" + cls + "'>" + text + "</" + element + ">";
      } else {
        return "<" + element + ">" + text + "</" + element + ">";
      }
    };
    wrapAddClass = function(text, element) {
      return extractClass(text, function(text, cls) {
        return renderElement(text, cls, element);
      });
    };
    renderer.heading = function(text, level) {
      return wrapAddClass(text, "h" + level);
    };
    renderer.paragraph = function(text) {
      return wrapAddClass(text, "p");
    };
    compilers.md = compilers.markdown = function(module, filename) {
      var content;
      content = md(fs.readFileSync(filename, "utf8"), {
        renderer: renderer
      });
      content = content.replace(/\\?"/g, "\\\"");
      content = content.replace(/\r?\n/g, "\\n");
      return module._compile("module.exports = \"" + content + "\"", filename);
    };
  } catch (_error) {
    err = _error;
  }

  try {
    Handlebars = require('handlebars');
    if (Handlebars && Handlebars.precompile) {
      compilers.hbs = compilers.handlebars = function(module, filename) {
        var content;
        content = Handlebars.precompile(fs.readFileSync(filename, 'utf8'));
        return module._compile("module.exports = " + content, filename);
      };
    }
  } catch (_error) {
    err = _error;
  }

  try {
    eco = require('eco');
    if (eco.precompile) {
      compilers.eco = function(module, filename) {
        var content;
        content = eco.precompile(fs.readFileSync(filename, 'utf8'));
        return module._compile("module.exports = " + content, filename);
      };
    } else {
      compilers.eco = function(module, filename) {
        var content;
        content = eco.compile(fs.readFileSync(filename, 'utf8'));
        return module._compile(content, filename);
      };
    }
  } catch (_error) {
    err = _error;
  }

  try {
    jade = require('jade');
    compilers.jade = function(module, filename) {
      var content, runtime;
      content = jade.compileClient(fs.readFileSync(filename, 'utf8'), {
        client: true
      });
      runtime = "\n\nvar jade={}; (function(exports) {" + (fs.readFileSync((require("path")).resolve(__dirname + "/../../jade/lib/runtime.js"), 'utf8')) + "})(jade)";
      return module._compile(runtime + "; module.exports = " + content, filename);
    };
  } catch (_error) {
    err = _error;
  }

  try {
    less = require('less');
    compilers.less = function(module, filename) {
      var content;
      content = fs.readFileSync(filename, 'utf8');
      return less.render(content, function(e, content) {
        return compilers.css(module, filename, content);
      });
    };
  } catch (_error) {
    err = _error;
  }

  try {
    compilers.css = function(module, filename, content) {
      var name;
      if (content == null) {
        content = null;
      }
      if (content === null) {
        content = fs.readFileSync(filename, 'utf8');
      }
      content = content.replace(/\\/g, "\\\\");
      content = content.replace(/\\?"/g, "\\\"");
      content = content.replace(/\r?\n/g, "\\n");
      name = filename.substr(filename.lastIndexOf(((process.platform.indexOf("win")) === 0 ? "\\" : "/")));
      name = name.substr(1, name.indexOf(".") - 1);
      return module._compile("s = document.createElement('style'); s.innerHTML = \"" + content + "\"; s.id = \"css-" + name + "\"; document.head.appendChild(s);", filename);
    };
  } catch (_error) {
    err = _error;
  }

  try {
    compilers.json = function(module, filename) {
      var content, name;
      content = fs.readFileSync(filename, 'utf8');
      content = content.replace(/\\?"/g, "\\\"");
      content = content.replace(/\r?\n/g, "\\n");
      name = filename.substr(filename.lastIndexOf(((process.platform.indexOf("win")) === 0 ? "\\" : "/")));
      name = name.substr(1, name.indexOf(".") - 1);
      return module._compile("if (!window.JSONImport) window.JSONImport = {};\nvar item = JSON.parse(\"" + content + "\");\nreturn window.JSONImport['" + name + "'] = module.exports = item;", filename);
    };
  } catch (_error) {
    error = _error;
  }

  try {
    yaml = require("js-yaml");
    compilers.yaml = function(module, filename) {
      var content, name;
      content = JSON.stringify(yaml.load((fs.readFileSync(filename, 'utf8')).replace(/:/g, ": ")));
      content = content.replace(/\\?"/g, "\\\"");
      content = content.replace(/\r?\n/g, "\\n");
      name = filename.substr(filename.lastIndexOf(((process.platform.indexOf("win")) === 0 ? "\\" : "/")));
      name = name.substr(1, name.indexOf(".") - 1);
      return module._compile("if (!window.JSONImport) window.JSONImport = {};\nvar item = JSON.parse(\"" + content + "\", function(key, value) { var v; try { v = eval(value) } catch(e) { v = value } return v;});\nreturn window.JSONImport['" + name + "'] = module.exports = item;", filename);
    };
  } catch (_error) {
    error = _error;
  }

  try {
    mime = require("mime");
    compilers.eot = compilers.woff = compilers.ttf = compilers.otf = compilers.png = compilers.gif = compilers.jpg = compilers.svg = compilers.jpeg = function(module, filename) {
      var content, name;
      content = fs.readFileSync(filename).toString("base64");
      name = filename.substr(filename.lastIndexOf(((process.platform.indexOf("win")) === 0 ? "\\" : "/")));
      name = name.substr(1, name.indexOf(".") - 1);
      return module._compile("if (!window.imagePackage) window.imagePackage = function() { return \"data:\" + this.mime + \";base64,\" + this.content };\nif (!window.otherImports) window.otherImports = {};\nvar item = {\n	mime: '" + (mime.lookup(filename)) + "',\n	content: '" + content + "'\n};\nitem.toString = function() { return window.imagePackage.apply(item, []); }\nreturn window.otherImports['" + name + "'] = module.exports = item;", filename);
    };
  } catch (_error) {
    error = _error;
  }

  exports.Package = Package = (function() {
    function Package(config) {
      this.compileFile = bind(this.compileFile, this);
      this.compileSources = bind(this.compileSources, this);
      this.compileDependencies = bind(this.compileDependencies, this);
      var ref1, ref2, ref3, ref4, ref5;
      this.identifier = (ref1 = config.identifier) != null ? ref1 : 'require';
      this.paths = (ref2 = config.paths) != null ? ref2 : ['lib'];
      this.dependencies = (ref3 = config.dependencies) != null ? ref3 : [];
      this.keeps = (ref4 = config.keeps) != null ? ref4 : [];
      this.compilers = _.extend({}, compilers, config.compilers);
      this.cache = (ref5 = config.cache) != null ? ref5 : true;
      this.mtimeCache = {};
      this.compileCache = {};
    }

    Package.prototype.compile = function(callback) {
      return async.parallel([this.compileDependencies, this.compileSources], function(err, parts) {
        if (err) {
          return callback(err);
        } else {
          return callback(null, parts.join("\n"));
        }
      });
    };

    Package.prototype.compileDependencies = function(callback) {
      return async.map(this.dependencies, this.compileFile, (function(_this) {
        return function(err, dependencySources) {
          if (err) {
            return callback(err);
          } else {
            return callback(null, dependencySources.join("\n"));
          }
        };
      })(this));
    };

    Package.prototype.compileSources = function(callback) {
      return async.reduce(this.paths, {}, _.bind(this.gatherSourcesFromPath, this), (function(_this) {
        return function(err, sources) {
          var filename, index, name, ref1, result, source;
          if (err) {
            return callback(err);
          }
          result = "(function(/*! Stitch !*/) {\n	if (!this." + _this.identifier + ") {\n		var modules = {}, cache = {}, require = function(name, root) {\n			var path = expand(root, name), module = cache[path], fn;\n			if (module) {\n				return module.exports;\n			} else if (fn = modules[path] || modules[path = expand(path, './index')]) {\n				module = {id: path, exports: {}};\n				try {\n					cache[path] = module;\n					fn(module.exports, function(name) {\n						return require(name, dirname(path));\n					}, module);\n					return module.exports;\n				} catch (err) {\n					delete cache[path];\n					throw err;\n				}\n			} else {\n				throw 'module \\'' + name + '\\' not found';\n			}\n		}, expand = function(root, name) {\n			var results = [], parts, part;\n			if (/^\\.\\.?(\\/|$)/.test(name)) {\n				parts = [root, name].join('/').split('/');\n			} else {\n				parts = name.split('/');\n			}\n			for (var i = 0, length = parts.length; i < length; i++) {\n				part = parts[i];\n				if (part == '..') {\n					results.pop();\n				} else if (part != '.' && part != '') {\n					results.push(part);\n				}\n			}\n			return results.join('/');\n		}, dirname = function(path) {\n			return path.split('/').slice(0, -1).join('/');\n		};\n		this." + _this.identifier + " = function(name) {\n			return require(name, '');\n		}\n		this." + _this.identifier + ".define = function(bundle) {\n			for (var key in bundle)\n				modules[key] = bundle[key];\n		};\n	}\n	return this." + _this.identifier + ".define;\n}).call(this)({";
          index = 0;
          for (name in sources) {
            ref1 = sources[name], filename = ref1.filename, source = ref1.source;
            name = name.replace(/[\\\\]/g, "/");
            result += index++ === 0 ? "" : ", ";
            result += JSON.stringify(name);
            result += ": function(exports, require, module) {" + source + "}";
          }
          result += "});\n";
          return callback(err, result);
        };
      })(this));
    };

    Package.prototype.createServer = function() {
      return (function(_this) {
        return function(req, res, next) {
          return _this.compile(function(err, source) {
            var message;
            if (err) {
              console.error("" + err.stack);
              message = "" + err.stack;
              res.writeHead(500, {
                'Content-Type': 'text/javascript'
              });
              return res.end("throw " + (JSON.stringify(message)));
            } else {
              res.writeHead(200, {
                'Content-Type': 'text/javascript'
              });
              return res.end(source);
            }
          });
        };
      })(this);
    };

    Package.prototype.gatherSourcesFromPath = function(sources, sourcePath, callback) {
      return fs.stat(sourcePath, (function(_this) {
        return function(err, stat) {
          if (err) {
            return callback(err);
          }
          if (stat.isDirectory()) {
            return _this.getFilesInTree(sourcePath, function(err, paths) {
              if (err) {
                return callback(err);
              }
              return async.reduce(paths, sources, _.bind(_this.gatherCompilableSource, _this), callback);
            });
          } else {
            return _this.gatherCompilableSource(sources, sourcePath, callback);
          }
        };
      })(this));
    };

    Package.prototype.gatherCompilableSource = function(sources, path, callback) {
      if (this.compilers[extname(path).slice(1)]) {
        return this.getRelativePath(path, (function(_this) {
          return function(err, relativePath) {
            if (err) {
              return callback(err);
            }
            return _this.compileFile(path, function(err, source) {
              var extension, key;
              if (err) {
                return callback(err);
              } else {
                extension = extname(relativePath);
                key = relativePath.slice(0, -extension.length);
                sources[key] = {
                  filename: relativePath,
                  source: source
                };
                return callback(err, sources);
              }
            });
          };
        })(this));
      } else {
        return callback(null, sources);
      }
    };

    Package.prototype.sharedStart = function() {
      var A, L, arr, i, word1, word2;
      arr = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      A = arr.slice(0).sort();
      word1 = A[0];
      word2 = A[A.length - 1];
      L = word1.length;
      i = 0;
      while (i < L && word1.charAt(i) === word2.charAt(i)) {
        i++;
      }
      return word1.substring(0, i);
    };

    Package.prototype.getRelativePath = function(path, callback) {
      return fs.realpath(path, (function(_this) {
        return function(err, sourcePath) {
          var keeps;
          sourcePath = path;
          if (err) {
            return callback(err);
          }
          keeps = _this.keeps;
          return async.map(_this.paths, fs.realpath, function(err, expandedPaths) {
            var add, base, expandedPath, j, k, keep, len, len1, post, pre, sp;
            if (err) {
              return callback(err);
            }
            for (j = 0, len = expandedPaths.length; j < len; j++) {
              expandedPath = expandedPaths[j];
              base = expandedPath + (process.platform.indexOf("win") === 0 ? "\\" : "/");
              if (sourcePath.indexOf(base) !== 0) {
                sourcePath = _this.sharedStart(base, sourcePath) + path;
              }
              add = false;
              for (k = 0, len1 = keeps.length; k < len1; k++) {
                keep = keeps[k];
                if ((sourcePath.match(keep.match)) != null) {
                  add = sourcePath.match(keep.keep);
                }
              }
              if (add) {
                pre = base.slice(0, base.indexOf(add[0]));
                post = base.slice((base.indexOf(add[0])) + add[0].length);
                sp = sourcePath.slice((sourcePath.indexOf(pre)) + pre.length);
                add = sourcePath.slice((sourcePath.indexOf(post)) + post.length);
                sp = sp.slice(0, sp.indexOf(post));
                sp = sp + add;
              } else {
                sp = sourcePath.replace(base, "");
              }
              return callback(null, sp);
            }
          });
        };
      })(this));
    };

    Package.prototype.compileFile = function(path, callback) {
      var compile, extension, mod, mtime, source;
      extension = extname(path).slice(1);
      if (this.cache && this.compileCache[path] && this.mtimeCache[path] === this.compileCache[path].mtime) {
        return callback(null, this.compileCache[path].source);
      } else if (compile = this.compilers[extension]) {
        source = null;
        mod = {
          _compile: function(content, filename) {
            return source = content;
          }
        };
        try {
          compile(mod, path);
          if (this.cache && (mtime = this.mtimeCache[path])) {
            this.compileCache[path] = {
              mtime: mtime,
              source: source
            };
          }
          return callback(null, source);
        } catch (_error) {
          err = _error;
          if (err instanceof Error) {
            err.message = "can't compile " + path + "\n" + err.message;
          } else {
            err = new Error("can't compile " + path + "\n" + err);
          }
          return callback(err);
        }
      } else {
        return callback(new Error("no compiler for '." + extension + "' files"));
      }
    };

    Package.prototype.walkTree = function(directory, callback) {
      return fs.readdir(directory, (function(_this) {
        return function(err, files) {
          if (err) {
            return callback(err);
          }
          return async.forEach(files, function(file, next) {
            var filename;
            if (file.match(/^\./)) {
              return next();
            }
            filename = join(directory, file);
            return fs.stat(filename, function(err, stats) {
              var ref1;
              _this.mtimeCache[filename] = stats != null ? (ref1 = stats.mtime) != null ? ref1.toString() : void 0 : void 0;
              if (!err && stats.isDirectory()) {
                return _this.walkTree(filename, function(err, filename) {
                  if (filename) {
                    return callback(err, filename);
                  } else {
                    return next();
                  }
                });
              } else {
                callback(err, filename);
                return next();
              }
            });
          }, callback);
        };
      })(this));
    };

    Package.prototype.getFilesInTree = function(directory, callback) {
      var files;
      files = [];
      return this.walkTree(directory, function(err, filename) {
        if (err) {
          return callback(err);
        } else if (filename) {
          return files.push(filename);
        } else {
          return callback(err, files.sort());
        }
      });
    };

    return Package;

  })();

  exports.createPackage = function(config) {
    return new Package(config);
  };

}).call(this);
